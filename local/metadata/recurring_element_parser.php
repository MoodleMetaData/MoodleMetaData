<?php

require_once 'lib.php';


/**
 *
 *  Should be used to save all data generated by a specific repeated element
 *
 *  Assumes that, for any new element, their primaryKey will either:
 *       Not have a set value (be null)
 *       Will have the value be -1
 *
 *  NOTE: THE PRIMARY KEY CANNOT BE STORED AS ID IN THE FORM. Instead, should be $tableName.'_id'
 *       - EG: coursesession_id, which will be loaded into 'id' for each element
 *
 *  For an example, see session_form::save_data
 *
 */
class recurring_element_parser {
    /**
     * Constructs the class
     *
     * @param string $tableName table name 
     * @param string $repeatedHiddenName name given to the repeating group. Stores the number of elements
     * @param array $allChangedAttributes array containing the ids of all elements that the user is able to edit. Do not need to be saved by this parser, but will be loaded from the given data.
     *      NOTE: If the table can be deleted, include the value that will store that
     * @param array $convertedAttributes optional array that should map from an element to a function that should be performed on that element.
     *      An example would be for 
     *
     */
    function __construct($tableName, $repeatedHiddenName, $allChangedAttributes, $convertedAttributes=array()) {
        $this->tableName = $tableName;
        $this->repeatedHiddenName = $repeatedHiddenName;
        $this->allChangedAttributes = $allChangedAttributes;
        $this->primaryKey = $tableName.'_id';

        $this->convertedAttributes = $convertedAttributes;
    }

    /**
     * Will parse the data given to the constructor (from a form), and return tuples for elements from data
     *
     * @param object $data value returned by the related form. Must NOT be null
     *
     * @return array of dictionaries, where each element in the array corresponds to tuple to be added/updated to database
     *    The objects will be pairs of attribute->value, for each of the attributes that could be changed
     *
     */
    function getTuplesFromData($data) {
        $data = get_object_vars($data);
        $numElements = $data[$this->repeatedHiddenName];
        
        $sessions = array();
        for ($index = 0; $index < $numElements; $index += 1) {
            $session = array();

            foreach ($this->allChangedAttributes as $element) {
                $longElement = $element.'['.$index.']';
                if (array_key_exists($element, $data) and array_key_exists($index, $data[$element])) {
                    // If it is in as just $element, use that
                    $session[$element] = $data[$element][$index];
                    
                } else if (array_key_exists($longElement, $data)) {
                    // Otherwise, access using $element[$index]
                    $session[$element] = $data[$longElement];
                    
                } else {
                    // The value of it was null
                    $session[$element] = null;
                }
            }

            $session['id'] = $data[$this->primaryKey][$index];

            if (!is_null($this->convertedAttributes)) {
                foreach($this->convertedAttributes as $element=>$func) {
                    if ($session[$element] != null) {
                        $session[$element] = $func($session[$element]);
                    }
                }
            }
            $sessions[] = $session;
        }

        return $sessions;
    }

    /**
     * If the given tuple is in the database, it will be removed. Otherwise, will not do any action
     *
     * @param object $tuple tuple that is to be removed from database.
     *
     */
    function deleteTupleFromDB($tuple) {
        if ($this->isInDatabase($tuple)) {
            global $DB;
            // Need to remove from DB
            $DB->delete_records($this->tableName, array('id'=>$tuple['id']));
        }
    }

    /**
     * Save all of the given tuples to the database
     *      For new elements, will update their ['id'] with the index they are inserted into
     *
     * Can include extra fields that will not be saved in the 
     *
     * @param array $tuples array of tuples to be updated in the database, or inserted into it.
     *
     */
    function saveTuplesToDB(&$tuples) {
        global $DB;
        
        foreach ($tuples as &$tuple) {
            // Two different cases for each tuple
            if ($this->isInDatabase($tuple)) {
                
                // Already exists in the database
                $DB->update_record($this->tableName, $tuple);
                
            } else {
                // Need to add to database
                $courseIdArray = array('courseid' => get_course_id());
                $inserted = array_merge($tuple, $courseIdArray);
                $tuple['id'] = $DB->insert_record($this->tableName, $inserted);
            }
        }
    }
    
    /**
     * Checks to see if the tuple is in the database. According to the assumptions listed in the class, expects a value to not
     *  be in the database if the value 'id' is null or equal to -1
     *
     * @param object $tuple tuple to check and see if it is in the database
     * @return boolean if the tuple is in the database, based on the id being set to a valid value
     *
     */
    private function isInDatabase($tuple) {
        return !is_null($tuple['id']) && $tuple['id'] != -1;
    }
}



?>
